
effect Stdio {
    read: () => string,
    write: (string) => void,
}

const hello = () => {
    "hello world"
}

const sayHi = () => {
    log(hello())
}

const respondWith = (responseValue: string) => (fn: () ={Stdio}> void) => {
    handle! fn {
        Stdio.read(() => k) => respondWith(responseValue)(() => k(responseValue)),
        Stdio.write((v) => k) => {
            log(v);
            respondWith(responseValue)(() => k())
        },
        pure(a) => a
    }
}

/*
should become
const inner = (handlers, done) => {
    log("getting");
    raise(handlers, "hash", 0, (handlers, arg1) => {
        const arg2 = " and ";
        raise(handlers, "hash", 0, (handlers, arg2) => {
            log(arg1 + arg2 + arg3);
            const arg1 = "And then ";
            raise(handlers, "hash", 0, (handlers, arg2) => {
                log(arg1 + arg2)
                log("Dones");
            })
        })
    })
}

ok, so we have a block (sequence)
and the first one is a `log`
neither it nor any params are CPS, so it prints normally.
next, we have something with an arg that has arg effects.
so first lets do the unoptimized version.
log ( ++ (++ (raise, "and"), raise))
so the log says
"arg 1, do your thing, assign yourself to "arg1"", then get back to me?
erm or log constructs itself as it would like to be treated
and then passes itself as the continuation?
and then what about the next bit?
the next bit says "here's me"
because this apply doesn't need anything special
yeah.

ok so usually people solve this by doing a-reduction or whatnot.
but while that is "clean" from an impl standpoint, the resulting
code is ridiculous.

party("one", log("awesome", farther("Farther")))
->
let p = party
let o = "one"

let l = log
let a = "awesome"

let f = farther
let fa = "Farther "

let fafa = farther("Farhter")

let lo = l(a, fafa)

let po = p(o, lo)

f(fa, (handlers, value) => p(o, l(a, value)))

becomes
farther("Farther", handlers, (handlers, value) => {
    log(value);
    // do the rest
})

*/

const farther = (name: string) => {
    log("farther " ++ name);
    raise!(Stdio.read())
}

const inner = (name: string) => {
    log(farther("Farther"));
    log("getting");
    log(name);
    log(raise!(Stdio.read()) ++ " and " ++ raise!(Stdio.read()));
    log("And then " ++ raise!(Stdio.read()));
    log("Dones")
}

const test1 = () => {
    respondWith("hello")(() => inner("Yes"))
}

sayHi()
test1()