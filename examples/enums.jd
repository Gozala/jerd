
// type Person = {
//     ...HasName,
//     ...HasAge,
//     what: int,
// }

type Id = {
    hash: string,
    size: int,
    pos: int,
}

// type UserReference = {
//     id: Id
// }
// enum Reference {
//     Builtin{name: string},
//     =UserReference
// }

type Some<T> = {
    value: T
}
type None = {}

enum Option<T> {
    Some<T>,
    None
}

type Twice<T> = {
    one: T,
    two: T,
}

enum OptionOrTwice<T> {
    ...Option<T>,
    Twice<T>
}

const x = Option<int>:Some<int>{_: 10}
const y = Option<int>:None
// Option<int> is a subtype of OptionOrTwice<int>, so this works
const y1 = OptionOrTwice<int>:y
const y2 = OptionOrTwice<int>:Twice<int>{one: 3, two: 10}

const something = Some<int>{_: 10}
// We can do enum conversion on variables too
const asOption = Option<int>:something

const useEnum = <T,>(x: Option<T>): bool => {
    switch x {
        Some => true,
        None => false
    }
}

// This now has type `Option<never>:None`, which can be coerced to anything.
// const z = Option:None

// Ok type-time representation of an enum value:
// its like...
// um do I need one?
// it's just a ref, right?
// And then you go to the definition, and plug & play type variable substitutions and such.
// yeah that should be fine.

/*

Ok I think I have a plan.

`EnumName:expression` is a type coersion of sorts.
if the expression resolves to a record that's part of this enum
or a subtype of this enum
then it's good!
otherwise it's a type error.
And maybe that's the whole shebang?
I'll want to do nice inference on type variables.

Also: `Option:None` becomes `Option<never>:None` which *is* a subtype
of any other kind of option. because never can't be produced, we have
a guarentee that any value that has the never type variable doesn't
actually use that variable.

*/
