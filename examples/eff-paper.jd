
// effect Read {
//     read: () => string,
// }
// effect Write {
//     write: (string) => void,
// }

// // TODO once I have tuples
// // const collect = <T,>(fn: () ={Stdio}> T): (string, T) => {
// //     handle! fn {
// //         Write.write((v) => k) => {
// //             let (collected, a) = collect(v);
// //             (collected ++ v, a)
// //         }
// //         pure(a) => ("", a)
// //     }
// // }

const tee = (x: string): string => {
    log("> " ++ x);
    x
}

// const print = (x: string) ={Write}> raise!(Write.write(x))
// const read = () ={Read}> raise!(Read.read())

// // const alwaysRead: {e}(string, () ={Read, e}> void) ={e}> void = {e}(value: string, fn: () ={Read, e}> void): void ={e}> {
// //     handle! fn {
// //         Read.Read(() => k) => {
// //             alwaysRead{e}(value, () => k(value))
// //         },
// //         pure(a) => a
// //     }
// // }

// const alwaysRead: (string, () ={Read, Write}> void) ={Write}> void = (value: string, fn: () ={Read, Write}> void): void ={Write}> {
//     handle! fn {
//         Read.read(() => k) => {
//             alwaysRead(value, () => k(value))
//         },
//         pure(a) => a
//     }
// }

// // This is so we can test the results
// const collect: (() ={Write}> void) => string = (fn: () ={Write}> void): string => {
//     handle! fn {
//         Write.write((v) => k) => {
//             v ++ "\n" ++ collect(k)
//         },
//         pure(a) => "end"
//     }
// }


// // Does collect work? Looks like it does
// collect((): void => {
//     raise!(Write.write("one"));
//     raise!(Write.write("two"));
//     raise!(Write.write("three"))
// }) == "one\ntwo\nthree\nend"

// // Does collect work? Looks like it does
// collect((): void => {
//     print("HI")
// }) == "HI\nend"

// // Here's the broken
// collect((): void => {
//     print("HI");
//     print("HO");
// }) == "HI\nHO\nend"

// // And this works
// collect((): void => {
//     raise!(Write.write("HI"));
//     raise!(Write.write("HO"));
// }) == "HI\nHO\nend"

// // Working
// collect(() => alwaysRead("hi", () => print(raise!(Read.read()) ++ " and " ++ raise!(Read.read())) )) == "hi and hi\nend"

// collect((): void => {
//     print("A");
//     print("B")
// }) == "A\nB\nend"

// collect(() => alwaysRead("hi", () => {
//     print(read());
//     print("YA");
//     print(read());
//     print("B")
// })) == "hi\nYA\nhi\nB\nend"


// collect(() => alwaysRead("hi", () => {
//     raise!(Write.write("A"));
//     const x = raise!(Read.read());
//     raise!(Write.write("B"));
// })) == "A\nB\nend"

// collect(() => alwaysRead("hi", () => {
//     const x = raise!(Read.read());
//     raise!(Write.write("B"));
// })) == "B\nend"

// // Here are the examples from the paper


// const printFullName = () ={Read, Write}> {
//     print("What is your forename?");
//     const foreName = raise!(Read.read());
//     print("What is your surname?");
//     const surName = raise!(Read.read());
//     print(foreName ++ " " ++ surName)
// }

// // Full first example from the eff paper
// // # 2.1.1
// collect((): void => {
//     alwaysRead("Me", printFullName)
// }) == "What is your forename?\nWhat is your surname?\nMe Me\nend"

// // This is so we can test the results
// const reverse: (() ={Write}> void) ={Write}> void = (fn: () ={Write}> void): void ={Write}> {
//     handle! fn {
//         Write.write((v) => k) => {
//             reverse(k);
//             print(v)
//         },
//         pure(a) => a
//     }
// }

// collect(() => reverse(() => {print("A"); print("B")})) == "B\nA\nend"

// // # 2.1.2
// collect((): void => {
//     reverse(() => {
//         alwaysRead("Me", printFullName)
//     })
// }) == "Me Me\nWhat is your surname?\nWhat is your forename?\nend"


// // # 2.3
effect Decide {
    decide: () => bool,
}
const decide = () ={Decide}> raise!(Decide.decide())

// const choose: <T,>(T, T) ={Decide}> T = <T,>(x: T, y: T): T ={Decide}> {
//     if decide() { x } else { y }
// }
// const pickTrue: <T,>(() ={Decide}> T) => T = <T,>(fn: () ={Decide}> T): T => handle! fn {
//     Decide.decide(() => k) => pickTrue<T>(() => k(true)),
//     pure(x) => x
// }
// const chooseDiff = () ={Decide}> {
//     const x1 = choose(15, 30);
//     const x2 = choose(5, 10);
//     x1 - x2
// }
// pickTrue<int>(chooseDiff) == 10

// // #2.3.1
// const pickMax: (() ={Decide}> int) => int = (fn: () ={Decide}> int): int => handle! fn {
//     Decide.decide(() => k) => {
//         const xt = pickMax(() => k(true));
//         const xf = pickMax(() => k(false));
//         if xt > xf { xt } else { xf }
//     },
//     pure(x) => x
// }
// pickMax(chooseDiff) == 25

// #2.3.2
effect Fail {
    fail: () => int, // TODO this should really be an exit continuation...
}
const decide = () ={Decide}> raise!(Decide.decide())
const fail = () ={Fail}> raise!(Fail.fail())

const chooseInt: (int, int) ={Decide, Fail}> int = (m: int, n: int): int ={Decide, Fail}> {
    if m > n {
        fail();
        10
    } else {
        if decide() {
            m
        } else {
            chooseInt(m + 1, n)
        }
    }
}

const pythagorean = (m: int, n: int) ={Decide, Fail}> {
    const a = chooseInt(m, n - 1);
    const b = chooseInt(a + 1, n);
    const a2 = a * a;
    const b2 = b * b;
    if isSquare(a2 + b2) {
        intToString(a) ++ ":" ++ intToString(b)
    } else {
        log("A: " ++ intToString(a) ++ " => " ++ intToString(a2));
        log("B: " ++ intToString(b) ++ " => " ++ intToString(b2));
        fail();
        "??? how did this return"
    }
}

// const backtrack: <T,>(() ={Decide, Fail}> T, T) ={}> T = <T,>(fn: () ={Decide, Fail}> T, default: T): T ={}> {
//     // what happens to fail here?
//     handle! () => {
//         handle! fn {
//             Fail.fail(() => _) => default,
//             pure(x) => x
//         }
//     } {
//         Decide.decide(() => k) => {
//             backtrack(() => handle! () => k(true) {
//                 Fail.fail(() => _) => k(false),
//                 pure(x) => x
//             }, default)
//         },
//         pure(x) => x
//     }
// }


// const backtrack: <T,>(() ={Decide, Fail}> T, T) ={}> T = <T,>(fn: () ={Decide, Fail}> T, default: T): T ={}> {
//     // what happens to fail here?
//     handle! () => handleFail(fn, () => default) {
//         Decide.decide(() => k) => {
//             backtrack(() => handleFail(() => k(true), ))
//             backtrack(() => handle! () => k(true) {
//                 Fail.fail(() => _) => k(false),
//                 pure(x) => x
//             }, default)
//         },
//         pure(x) => x
//     }
// }

const handleFail = <T,>(fn: () ={Decide, Fail}> T, orElse: () ={Decide}> T) ={Decide}> handle! fn {
    Fail.fail(() => _) => orElse(),
    pure(x) => x
}

const handleFailPure = <T,>(fn: () ={Fail}> T, orElse: () ={}> T) ={}> handle! fn {
    Fail.fail(() => _) => orElse(),
    pure(x) => x
}


const backtrack: <T,>(() ={Decide, Fail}> T) ={Fail}> T = <T,>(fn: () ={Decide, Fail}> T): T ={Fail}> {
    handle! fn {
        Decide.decide(() => k) => {
            backtrack(() => handleFail(() => k(true), () => k(false)))
            // backtrack(() => handleFail(() => k(true), ))
            // backtrack(() => handle! () => k(true) {
            //     Fail.fail(() => _) => k(false),
            //     pure(x) => x
            // }, default)
        },
        pure(x) => x
    }
}

if isSquare(5) {
    log("NO")
} else {
    log("WHAT")
}

tee(handleFailPure<string>(() => backtrack<string>(() => pythagorean(4, 15)), () => "No solution found")) == "5:12"