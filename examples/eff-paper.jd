
effect Read {
    read: () => string,
}
effect Write {
    write: (string) => void,
}

// TODO once I have tuples
// const collect = <T,>(fn: () ={Stdio}> T): (string, T) => {
//     handle! fn {
//         Write.write((v) => k) => {
//             let (collected, a) = collect(v);
//             (collected ++ v, a)
//         }
//         pure(a) => ("", a)
//     }
// }

const tee = (x: string): string => {
    log(x);
    x
}

const print = (x: string) ={Write}> raise!(Write.write(x))
const read = () ={Read}> raise!(Read.read())

// const alwaysRead: {e}(string, () ={Read, e}> void) ={e}> void = {e}(value: string, fn: () ={Read, e}> void): void ={e}> {
//     handle! fn {
//         Read.Read(() => k) => {
//             alwaysRead{e}(value, () => k(value))
//         },
//         pure(a) => a
//     }
// }

const alwaysRead: (string, () ={Read, Write}> void) ={Write}> void = (value: string, fn: () ={Read, Write}> void): void ={Write}> {
    handle! fn {
        Read.read(() => k) => {
            alwaysRead(value, () => k(value))
        },
        pure(a) => a
    }
}

// This is so we can test the results
const collect: (() ={Write}> void) => string = (fn: () ={Write}> void): string => {
    handle! fn {
        Write.write((v) => k) => {
            v ++ collect(k)
        },
        pure(a) => "end"
    }
}


// Does collect work? Looks like it does
collect((): void => {
    raise!(Write.write("one"));
    raise!(Write.write("two"));
    raise!(Write.write("three"))
}) == "onetwothreeend"

// Does collect work? Looks like it does
tee(collect((): void => {
    print("HI")
})) == "HIend"

// Here's the broken
tee(collect((): void => {
    print("HI");
    print("HO");
})) == "HIHOend"

// And this works
tee(collect((): void => {
    raise!(Write.write("HI"));
    raise!(Write.write("HO"));
})) == "HIHOend"

// Working
tee(collect(() => alwaysRead("hi", () => print(raise!(Read.read()) ++ " and " ++ raise!(Read.read())) ))) == "hi and hiend"

tee(collect((): void => {
    print("A");
    print("B")
})) == "ABend"

tee(collect(() => alwaysRead("hi", () => {
    print(read());
    print("YA");
    print(read());
    print("B")
}))) == "hiYAhiBend"


tee(collect(() => alwaysRead("hi", () => {
    raise!(Write.write("A"));
    const x = raise!(Read.read());
    raise!(Write.write("B"));
}))) == "ABend"

tee(collect(() => alwaysRead("hi", () => {
    const x = raise!(Read.read());
    raise!(Write.write("B"));
}))) == "Bend"

// Here are the examples from the paper


const printFullName = () ={Read, Write}> {
    print("What is your forename?");
    const foreName = raise!(Read.read());
    print("What is your surname?");
    const surName = raise!(Read.read());
    print(foreName ++ " " ++ surName)
}

// Full first example from the eff paper
tee(collect((): void => {
    alwaysRead("Me", printFullName)
})) == "What is your forename?What is your surname?Me Meend"

// This is so we can test the results
const reverse: (() ={Write}> void) ={Write}> void = (fn: () ={Write}> void): void ={Write}> {
    handle! fn {
        Write.write((v) => k) => {
            reverse(k);
            print(v)
        },
        pure(a) => a
    }
}

tee(collect(() => reverse(() => {print("A"); print("B")}))) == "BAend"

// Full second example from the eff paper
tee(collect((): void => {
    reverse(() => {
        alwaysRead("Me", printFullName)
    })
})) == "Me MeWhat is your surname?What is your forename?end"


