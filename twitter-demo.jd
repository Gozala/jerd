
effect Read {
    read: () => string,
}

// TODO when I've got type arguments, make this generic.
const respondWith:
    (string) => (() ={Read}> void) => void
 = (responseValue: string) => (fn: () ={Read}> void) => {
    handle! fn {
        Read.read(() => k) => respondWith(responseValue ++ ".")(() => k(responseValue)),
        pure(a) => a
    }
}

const farther = (name: string) => {
    log("yes please " ++ name);
    raise!(Read.read())
}

const inner = (name: string) => {
    log(farther("Folks") ++ " from farther");
    log("getting");
    log(name);
    log(raise!(Read.read()) ++ " and " ++ raise!(Read.read()));
    log("And then " ++ raise!(Read.read()));
    log("Dones")
}

const test1 = () => {
    respondWith("<read>")(() => inner("Yes"))
}

// sayHi()
test1()
